// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BchrpcClient is the client API for Bchrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BchrpcClient interface {
	// GetMempoolInfo returns the state of the current mempool.
	GetMempoolInfo(ctx context.Context, in *GetMempoolInfoRequest, opts ...grpc.CallOption) (*GetMempoolInfoResponse, error)
	// GetMempool returns information about all transactions currently in the memory pool.
	// Offers an option to return full transactions or just transactions hashes.
	GetMempool(ctx context.Context, in *GetMempoolRequest, opts ...grpc.CallOption) (*GetMempoolResponse, error)
	// GetBlockchainInfo returns data about the blockchain including the most recent
	// block hash and height.
	GetBlockchainInfo(ctx context.Context, in *GetBlockchainInfoRequest, opts ...grpc.CallOption) (*GetBlockchainInfoResponse, error)
	// GetBlockInfo returns metadata and info for a specified block.
	GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error)
	// GetBlock returns detailed data for a block.
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
	// GetRawBlock returns a block in a serialized format.
	GetRawBlock(ctx context.Context, in *GetRawBlockRequest, opts ...grpc.CallOption) (*GetRawBlockResponse, error)
	// GetBlockFilter returns the compact filter (cf) of a block as a Golomb-Rice encoded set.
	//
	// **Requires CfIndex**
	GetBlockFilter(ctx context.Context, in *GetBlockFilterRequest, opts ...grpc.CallOption) (*GetBlockFilterResponse, error)
	// GetHeaders takes a block locator object and returns a batch of no more than 2000
	// headers. Upon parsing the block locator, if the server concludes there has been a
	// fork, it will send headers starting at the fork point, or genesis if no blocks in
	// the locator are in the best chain. If the locator is already at the tip no headers
	// will be returned.
	// see: bchd/bchrpc/documentation/wallet_operation.md
	GetHeaders(ctx context.Context, in *GetHeadersRequest, opts ...grpc.CallOption) (*GetHeadersResponse, error)
	// GetTransaction returns a transaction given a transaction hash.
	//
	// **Requires TxIndex**
	// **Requires SlpIndex for slp related information **
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// GetRawTransaction returns a serialized transaction given a transaction hash.
	//
	// **Requires TxIndex**
	GetRawTransaction(ctx context.Context, in *GetRawTransactionRequest, opts ...grpc.CallOption) (*GetRawTransactionResponse, error)
	// GetAddressTransactions returns the transactions for the given address. Offers offset,
	// limit, and from block options.
	//
	// **Requires AddressIndex**
	// **Requires SlpIndex for slp related information **
	GetAddressTransactions(ctx context.Context, in *GetAddressTransactionsRequest, opts ...grpc.CallOption) (*GetAddressTransactionsResponse, error)
	// GetRawAddressTransactions the serialized raw transactions for
	// the given address. Offers offset, limit, and from block options.
	//
	// **Requires AddressIndex**
	GetRawAddressTransactions(ctx context.Context, in *GetRawAddressTransactionsRequest, opts ...grpc.CallOption) (*GetRawAddressTransactionsResponse, error)
	// GetAddressUnspentOutputs returns all the unspent transaction outputs
	// for the given address.
	//
	// **Requires AddressIndex**
	// **Requires SlpIndex for slp related information **
	GetAddressUnspentOutputs(ctx context.Context, in *GetAddressUnspentOutputsRequest, opts ...grpc.CallOption) (*GetAddressUnspentOutputsResponse, error)
	// GetUnspentOutput takes an unspent output in the utxo set and returns
	// the utxo metadata or not found.
	//
	// **Requires SlpIndex for slp related information **
	GetUnspentOutput(ctx context.Context, in *GetUnspentOutputRequest, opts ...grpc.CallOption) (*GetUnspentOutputResponse, error)
	// GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
	// in the provided block.
	//
	// **Requires TxIndex**
	GetMerkleProof(ctx context.Context, in *GetMerkleProofRequest, opts ...grpc.CallOption) (*GetMerkleProofResponse, error)
	// GetSlpTokenMetadata return slp token metadata for one or more tokens.
	//
	// **Requires SlpIndex**
	GetSlpTokenMetadata(ctx context.Context, in *GetSlpTokenMetadataRequest, opts ...grpc.CallOption) (*GetSlpTokenMetadataResponse, error)
	// GetSlpParsedScript returns marshalled object from parsing an slp pubKeyScript
	// using goslp package.  This endpoint does not require SlpIndex.
	GetSlpParsedScript(ctx context.Context, in *GetSlpParsedScriptRequest, opts ...grpc.CallOption) (*GetSlpParsedScriptResponse, error)
	// GetSlpTrustedValidation returns slp validity related information for one or more transactions.
	//
	// **Requires SlpIndex**
	GetSlpTrustedValidation(ctx context.Context, in *GetSlpTrustedValidationRequest, opts ...grpc.CallOption) (*GetSlpTrustedValidationResponse, error)
	// CheckSlpTransaction checks the validity of a supposed slp transaction before it is broadcasted.
	CheckSlpTransaction(ctx context.Context, in *CheckSlpTransactionRequest, opts ...grpc.CallOption) (*CheckSlpTransactionResponse, error)
	// Submit a transaction to all connected peers.
	SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error)
	// SubscribeTransactions creates subscription to all relevant transactions based on
	// the subscription filter.
	//
	// This RPC does not use bidirectional streams and therefore can be used
	// with grpc-web. You will need to close and reopen the stream whenever
	// you want to update the subscription filter. If you are not using grpc-web
	// then SubscribeTransactionStream is more appropriate.
	//
	// **Requires TxIndex to receive input metadata**
	// **Requires SlpIndex to receive slp input/output metadata, or SlpTokenMetadata**
	SubscribeTransactions(ctx context.Context, in *SubscribeTransactionsRequest, opts ...grpc.CallOption) (Bchrpc_SubscribeTransactionsClient, error)
	// SubscribeTransactionStream subscribes to relevant transactions based on
	// the subscription requests. The parameters to filter transactions on can
	// be updated by sending new SubscribeTransactionsRequest objects on the stream.
	//
	// NOTE: Because this RPC is using bi-directional streaming it cannot be used with
	// grpc-web.
	//
	// **Requires TxIndex to receive input metadata**
	SubscribeTransactionStream(ctx context.Context, opts ...grpc.CallOption) (Bchrpc_SubscribeTransactionStreamClient, error)
	// SubscribeBlocks creates a subscription for notifications of new blocks being
	// connected to the blockchain or blocks being disconnected.
	SubscribeBlocks(ctx context.Context, in *SubscribeBlocksRequest, opts ...grpc.CallOption) (Bchrpc_SubscribeBlocksClient, error)
}

type bchrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewBchrpcClient(cc grpc.ClientConnInterface) BchrpcClient {
	return &bchrpcClient{cc}
}

func (c *bchrpcClient) GetMempoolInfo(ctx context.Context, in *GetMempoolInfoRequest, opts ...grpc.CallOption) (*GetMempoolInfoResponse, error) {
	out := new(GetMempoolInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetMempoolInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetMempool(ctx context.Context, in *GetMempoolRequest, opts ...grpc.CallOption) (*GetMempoolResponse, error) {
	out := new(GetMempoolResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetMempool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetBlockchainInfo(ctx context.Context, in *GetBlockchainInfoRequest, opts ...grpc.CallOption) (*GetBlockchainInfoResponse, error) {
	out := new(GetBlockchainInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetBlockchainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error) {
	out := new(GetBlockInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) {
	out := new(GetBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetRawBlock(ctx context.Context, in *GetRawBlockRequest, opts ...grpc.CallOption) (*GetRawBlockResponse, error) {
	out := new(GetRawBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetRawBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetBlockFilter(ctx context.Context, in *GetBlockFilterRequest, opts ...grpc.CallOption) (*GetBlockFilterResponse, error) {
	out := new(GetBlockFilterResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetBlockFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetHeaders(ctx context.Context, in *GetHeadersRequest, opts ...grpc.CallOption) (*GetHeadersResponse, error) {
	out := new(GetHeadersResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetRawTransaction(ctx context.Context, in *GetRawTransactionRequest, opts ...grpc.CallOption) (*GetRawTransactionResponse, error) {
	out := new(GetRawTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetRawTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetAddressTransactions(ctx context.Context, in *GetAddressTransactionsRequest, opts ...grpc.CallOption) (*GetAddressTransactionsResponse, error) {
	out := new(GetAddressTransactionsResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetAddressTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetRawAddressTransactions(ctx context.Context, in *GetRawAddressTransactionsRequest, opts ...grpc.CallOption) (*GetRawAddressTransactionsResponse, error) {
	out := new(GetRawAddressTransactionsResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetRawAddressTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetAddressUnspentOutputs(ctx context.Context, in *GetAddressUnspentOutputsRequest, opts ...grpc.CallOption) (*GetAddressUnspentOutputsResponse, error) {
	out := new(GetAddressUnspentOutputsResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetAddressUnspentOutputs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetUnspentOutput(ctx context.Context, in *GetUnspentOutputRequest, opts ...grpc.CallOption) (*GetUnspentOutputResponse, error) {
	out := new(GetUnspentOutputResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetUnspentOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetMerkleProof(ctx context.Context, in *GetMerkleProofRequest, opts ...grpc.CallOption) (*GetMerkleProofResponse, error) {
	out := new(GetMerkleProofResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetMerkleProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetSlpTokenMetadata(ctx context.Context, in *GetSlpTokenMetadataRequest, opts ...grpc.CallOption) (*GetSlpTokenMetadataResponse, error) {
	out := new(GetSlpTokenMetadataResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetSlpTokenMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetSlpParsedScript(ctx context.Context, in *GetSlpParsedScriptRequest, opts ...grpc.CallOption) (*GetSlpParsedScriptResponse, error) {
	out := new(GetSlpParsedScriptResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetSlpParsedScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) GetSlpTrustedValidation(ctx context.Context, in *GetSlpTrustedValidationRequest, opts ...grpc.CallOption) (*GetSlpTrustedValidationResponse, error) {
	out := new(GetSlpTrustedValidationResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/GetSlpTrustedValidation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) CheckSlpTransaction(ctx context.Context, in *CheckSlpTransactionRequest, opts ...grpc.CallOption) (*CheckSlpTransactionResponse, error) {
	out := new(CheckSlpTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/CheckSlpTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error) {
	out := new(SubmitTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.bchrpc/SubmitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bchrpcClient) SubscribeTransactions(ctx context.Context, in *SubscribeTransactionsRequest, opts ...grpc.CallOption) (Bchrpc_SubscribeTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Bchrpc_ServiceDesc.Streams[0], "/pb.bchrpc/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &bchrpcSubscribeTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bchrpc_SubscribeTransactionsClient interface {
	Recv() (*TransactionNotification, error)
	grpc.ClientStream
}

type bchrpcSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *bchrpcSubscribeTransactionsClient) Recv() (*TransactionNotification, error) {
	m := new(TransactionNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bchrpcClient) SubscribeTransactionStream(ctx context.Context, opts ...grpc.CallOption) (Bchrpc_SubscribeTransactionStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Bchrpc_ServiceDesc.Streams[1], "/pb.bchrpc/SubscribeTransactionStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &bchrpcSubscribeTransactionStreamClient{stream}
	return x, nil
}

type Bchrpc_SubscribeTransactionStreamClient interface {
	Send(*SubscribeTransactionsRequest) error
	Recv() (*TransactionNotification, error)
	grpc.ClientStream
}

type bchrpcSubscribeTransactionStreamClient struct {
	grpc.ClientStream
}

func (x *bchrpcSubscribeTransactionStreamClient) Send(m *SubscribeTransactionsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bchrpcSubscribeTransactionStreamClient) Recv() (*TransactionNotification, error) {
	m := new(TransactionNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bchrpcClient) SubscribeBlocks(ctx context.Context, in *SubscribeBlocksRequest, opts ...grpc.CallOption) (Bchrpc_SubscribeBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &Bchrpc_ServiceDesc.Streams[2], "/pb.bchrpc/SubscribeBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &bchrpcSubscribeBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bchrpc_SubscribeBlocksClient interface {
	Recv() (*BlockNotification, error)
	grpc.ClientStream
}

type bchrpcSubscribeBlocksClient struct {
	grpc.ClientStream
}

func (x *bchrpcSubscribeBlocksClient) Recv() (*BlockNotification, error) {
	m := new(BlockNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BchrpcServer is the server API for Bchrpc service.
// All implementations must embed UnimplementedBchrpcServer
// for forward compatibility
type BchrpcServer interface {
	// GetMempoolInfo returns the state of the current mempool.
	GetMempoolInfo(context.Context, *GetMempoolInfoRequest) (*GetMempoolInfoResponse, error)
	// GetMempool returns information about all transactions currently in the memory pool.
	// Offers an option to return full transactions or just transactions hashes.
	GetMempool(context.Context, *GetMempoolRequest) (*GetMempoolResponse, error)
	// GetBlockchainInfo returns data about the blockchain including the most recent
	// block hash and height.
	GetBlockchainInfo(context.Context, *GetBlockchainInfoRequest) (*GetBlockchainInfoResponse, error)
	// GetBlockInfo returns metadata and info for a specified block.
	GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error)
	// GetBlock returns detailed data for a block.
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
	// GetRawBlock returns a block in a serialized format.
	GetRawBlock(context.Context, *GetRawBlockRequest) (*GetRawBlockResponse, error)
	// GetBlockFilter returns the compact filter (cf) of a block as a Golomb-Rice encoded set.
	//
	// **Requires CfIndex**
	GetBlockFilter(context.Context, *GetBlockFilterRequest) (*GetBlockFilterResponse, error)
	// GetHeaders takes a block locator object and returns a batch of no more than 2000
	// headers. Upon parsing the block locator, if the server concludes there has been a
	// fork, it will send headers starting at the fork point, or genesis if no blocks in
	// the locator are in the best chain. If the locator is already at the tip no headers
	// will be returned.
	// see: bchd/bchrpc/documentation/wallet_operation.md
	GetHeaders(context.Context, *GetHeadersRequest) (*GetHeadersResponse, error)
	// GetTransaction returns a transaction given a transaction hash.
	//
	// **Requires TxIndex**
	// **Requires SlpIndex for slp related information **
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	// GetRawTransaction returns a serialized transaction given a transaction hash.
	//
	// **Requires TxIndex**
	GetRawTransaction(context.Context, *GetRawTransactionRequest) (*GetRawTransactionResponse, error)
	// GetAddressTransactions returns the transactions for the given address. Offers offset,
	// limit, and from block options.
	//
	// **Requires AddressIndex**
	// **Requires SlpIndex for slp related information **
	GetAddressTransactions(context.Context, *GetAddressTransactionsRequest) (*GetAddressTransactionsResponse, error)
	// GetRawAddressTransactions the serialized raw transactions for
	// the given address. Offers offset, limit, and from block options.
	//
	// **Requires AddressIndex**
	GetRawAddressTransactions(context.Context, *GetRawAddressTransactionsRequest) (*GetRawAddressTransactionsResponse, error)
	// GetAddressUnspentOutputs returns all the unspent transaction outputs
	// for the given address.
	//
	// **Requires AddressIndex**
	// **Requires SlpIndex for slp related information **
	GetAddressUnspentOutputs(context.Context, *GetAddressUnspentOutputsRequest) (*GetAddressUnspentOutputsResponse, error)
	// GetUnspentOutput takes an unspent output in the utxo set and returns
	// the utxo metadata or not found.
	//
	// **Requires SlpIndex for slp related information **
	GetUnspentOutput(context.Context, *GetUnspentOutputRequest) (*GetUnspentOutputResponse, error)
	// GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
	// in the provided block.
	//
	// **Requires TxIndex**
	GetMerkleProof(context.Context, *GetMerkleProofRequest) (*GetMerkleProofResponse, error)
	// GetSlpTokenMetadata return slp token metadata for one or more tokens.
	//
	// **Requires SlpIndex**
	GetSlpTokenMetadata(context.Context, *GetSlpTokenMetadataRequest) (*GetSlpTokenMetadataResponse, error)
	// GetSlpParsedScript returns marshalled object from parsing an slp pubKeyScript
	// using goslp package.  This endpoint does not require SlpIndex.
	GetSlpParsedScript(context.Context, *GetSlpParsedScriptRequest) (*GetSlpParsedScriptResponse, error)
	// GetSlpTrustedValidation returns slp validity related information for one or more transactions.
	//
	// **Requires SlpIndex**
	GetSlpTrustedValidation(context.Context, *GetSlpTrustedValidationRequest) (*GetSlpTrustedValidationResponse, error)
	// CheckSlpTransaction checks the validity of a supposed slp transaction before it is broadcasted.
	CheckSlpTransaction(context.Context, *CheckSlpTransactionRequest) (*CheckSlpTransactionResponse, error)
	// Submit a transaction to all connected peers.
	SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error)
	// SubscribeTransactions creates subscription to all relevant transactions based on
	// the subscription filter.
	//
	// This RPC does not use bidirectional streams and therefore can be used
	// with grpc-web. You will need to close and reopen the stream whenever
	// you want to update the subscription filter. If you are not using grpc-web
	// then SubscribeTransactionStream is more appropriate.
	//
	// **Requires TxIndex to receive input metadata**
	// **Requires SlpIndex to receive slp input/output metadata, or SlpTokenMetadata**
	SubscribeTransactions(*SubscribeTransactionsRequest, Bchrpc_SubscribeTransactionsServer) error
	// SubscribeTransactionStream subscribes to relevant transactions based on
	// the subscription requests. The parameters to filter transactions on can
	// be updated by sending new SubscribeTransactionsRequest objects on the stream.
	//
	// NOTE: Because this RPC is using bi-directional streaming it cannot be used with
	// grpc-web.
	//
	// **Requires TxIndex to receive input metadata**
	SubscribeTransactionStream(Bchrpc_SubscribeTransactionStreamServer) error
	// SubscribeBlocks creates a subscription for notifications of new blocks being
	// connected to the blockchain or blocks being disconnected.
	SubscribeBlocks(*SubscribeBlocksRequest, Bchrpc_SubscribeBlocksServer) error
	mustEmbedUnimplementedBchrpcServer()
}

// UnimplementedBchrpcServer must be embedded to have forward compatible implementations.
type UnimplementedBchrpcServer struct {
}

func (UnimplementedBchrpcServer) GetMempoolInfo(context.Context, *GetMempoolInfoRequest) (*GetMempoolInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMempoolInfo not implemented")
}
func (UnimplementedBchrpcServer) GetMempool(context.Context, *GetMempoolRequest) (*GetMempoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMempool not implemented")
}
func (UnimplementedBchrpcServer) GetBlockchainInfo(context.Context, *GetBlockchainInfoRequest) (*GetBlockchainInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockchainInfo not implemented")
}
func (UnimplementedBchrpcServer) GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedBchrpcServer) GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBchrpcServer) GetRawBlock(context.Context, *GetRawBlockRequest) (*GetRawBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawBlock not implemented")
}
func (UnimplementedBchrpcServer) GetBlockFilter(context.Context, *GetBlockFilterRequest) (*GetBlockFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockFilter not implemented")
}
func (UnimplementedBchrpcServer) GetHeaders(context.Context, *GetHeadersRequest) (*GetHeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeaders not implemented")
}
func (UnimplementedBchrpcServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedBchrpcServer) GetRawTransaction(context.Context, *GetRawTransactionRequest) (*GetRawTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawTransaction not implemented")
}
func (UnimplementedBchrpcServer) GetAddressTransactions(context.Context, *GetAddressTransactionsRequest) (*GetAddressTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressTransactions not implemented")
}
func (UnimplementedBchrpcServer) GetRawAddressTransactions(context.Context, *GetRawAddressTransactionsRequest) (*GetRawAddressTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawAddressTransactions not implemented")
}
func (UnimplementedBchrpcServer) GetAddressUnspentOutputs(context.Context, *GetAddressUnspentOutputsRequest) (*GetAddressUnspentOutputsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressUnspentOutputs not implemented")
}
func (UnimplementedBchrpcServer) GetUnspentOutput(context.Context, *GetUnspentOutputRequest) (*GetUnspentOutputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnspentOutput not implemented")
}
func (UnimplementedBchrpcServer) GetMerkleProof(context.Context, *GetMerkleProofRequest) (*GetMerkleProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMerkleProof not implemented")
}
func (UnimplementedBchrpcServer) GetSlpTokenMetadata(context.Context, *GetSlpTokenMetadataRequest) (*GetSlpTokenMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlpTokenMetadata not implemented")
}
func (UnimplementedBchrpcServer) GetSlpParsedScript(context.Context, *GetSlpParsedScriptRequest) (*GetSlpParsedScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlpParsedScript not implemented")
}
func (UnimplementedBchrpcServer) GetSlpTrustedValidation(context.Context, *GetSlpTrustedValidationRequest) (*GetSlpTrustedValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlpTrustedValidation not implemented")
}
func (UnimplementedBchrpcServer) CheckSlpTransaction(context.Context, *CheckSlpTransactionRequest) (*CheckSlpTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSlpTransaction not implemented")
}
func (UnimplementedBchrpcServer) SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTransaction not implemented")
}
func (UnimplementedBchrpcServer) SubscribeTransactions(*SubscribeTransactionsRequest, Bchrpc_SubscribeTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTransactions not implemented")
}
func (UnimplementedBchrpcServer) SubscribeTransactionStream(Bchrpc_SubscribeTransactionStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTransactionStream not implemented")
}
func (UnimplementedBchrpcServer) SubscribeBlocks(*SubscribeBlocksRequest, Bchrpc_SubscribeBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeBlocks not implemented")
}
func (UnimplementedBchrpcServer) mustEmbedUnimplementedBchrpcServer() {}

// UnsafeBchrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BchrpcServer will
// result in compilation errors.
type UnsafeBchrpcServer interface {
	mustEmbedUnimplementedBchrpcServer()
}

func RegisterBchrpcServer(s grpc.ServiceRegistrar, srv BchrpcServer) {
	s.RegisterService(&Bchrpc_ServiceDesc, srv)
}

func _Bchrpc_GetMempoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMempoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetMempoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetMempoolInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetMempoolInfo(ctx, req.(*GetMempoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetMempool(ctx, req.(*GetMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetBlockchainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockchainInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetBlockchainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetBlockchainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetBlockchainInfo(ctx, req.(*GetBlockchainInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetBlockInfo(ctx, req.(*GetBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetRawBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetRawBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetRawBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetRawBlock(ctx, req.(*GetRawBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetBlockFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetBlockFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetBlockFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetBlockFilter(ctx, req.(*GetBlockFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetHeaders(ctx, req.(*GetHeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetRawTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetRawTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetRawTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetRawTransaction(ctx, req.(*GetRawTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetAddressTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetAddressTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetAddressTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetAddressTransactions(ctx, req.(*GetAddressTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetRawAddressTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawAddressTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetRawAddressTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetRawAddressTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetRawAddressTransactions(ctx, req.(*GetRawAddressTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetAddressUnspentOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressUnspentOutputsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetAddressUnspentOutputs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetAddressUnspentOutputs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetAddressUnspentOutputs(ctx, req.(*GetAddressUnspentOutputsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetUnspentOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnspentOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetUnspentOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetUnspentOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetUnspentOutput(ctx, req.(*GetUnspentOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetMerkleProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMerkleProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetMerkleProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetMerkleProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetMerkleProof(ctx, req.(*GetMerkleProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetSlpTokenMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlpTokenMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetSlpTokenMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetSlpTokenMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetSlpTokenMetadata(ctx, req.(*GetSlpTokenMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetSlpParsedScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlpParsedScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetSlpParsedScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetSlpParsedScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetSlpParsedScript(ctx, req.(*GetSlpParsedScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_GetSlpTrustedValidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlpTrustedValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).GetSlpTrustedValidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/GetSlpTrustedValidation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).GetSlpTrustedValidation(ctx, req.(*GetSlpTrustedValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_CheckSlpTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSlpTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).CheckSlpTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/CheckSlpTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).CheckSlpTransaction(ctx, req.(*CheckSlpTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BchrpcServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.bchrpc/SubmitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BchrpcServer).SubmitTransaction(ctx, req.(*SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bchrpc_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BchrpcServer).SubscribeTransactions(m, &bchrpcSubscribeTransactionsServer{stream})
}

type Bchrpc_SubscribeTransactionsServer interface {
	Send(*TransactionNotification) error
	grpc.ServerStream
}

type bchrpcSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *bchrpcSubscribeTransactionsServer) Send(m *TransactionNotification) error {
	return x.ServerStream.SendMsg(m)
}

func _Bchrpc_SubscribeTransactionStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BchrpcServer).SubscribeTransactionStream(&bchrpcSubscribeTransactionStreamServer{stream})
}

type Bchrpc_SubscribeTransactionStreamServer interface {
	Send(*TransactionNotification) error
	Recv() (*SubscribeTransactionsRequest, error)
	grpc.ServerStream
}

type bchrpcSubscribeTransactionStreamServer struct {
	grpc.ServerStream
}

func (x *bchrpcSubscribeTransactionStreamServer) Send(m *TransactionNotification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bchrpcSubscribeTransactionStreamServer) Recv() (*SubscribeTransactionsRequest, error) {
	m := new(SubscribeTransactionsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Bchrpc_SubscribeBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BchrpcServer).SubscribeBlocks(m, &bchrpcSubscribeBlocksServer{stream})
}

type Bchrpc_SubscribeBlocksServer interface {
	Send(*BlockNotification) error
	grpc.ServerStream
}

type bchrpcSubscribeBlocksServer struct {
	grpc.ServerStream
}

func (x *bchrpcSubscribeBlocksServer) Send(m *BlockNotification) error {
	return x.ServerStream.SendMsg(m)
}

// Bchrpc_ServiceDesc is the grpc.ServiceDesc for Bchrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Bchrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.bchrpc",
	HandlerType: (*BchrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMempoolInfo",
			Handler:    _Bchrpc_GetMempoolInfo_Handler,
		},
		{
			MethodName: "GetMempool",
			Handler:    _Bchrpc_GetMempool_Handler,
		},
		{
			MethodName: "GetBlockchainInfo",
			Handler:    _Bchrpc_GetBlockchainInfo_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _Bchrpc_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _Bchrpc_GetBlock_Handler,
		},
		{
			MethodName: "GetRawBlock",
			Handler:    _Bchrpc_GetRawBlock_Handler,
		},
		{
			MethodName: "GetBlockFilter",
			Handler:    _Bchrpc_GetBlockFilter_Handler,
		},
		{
			MethodName: "GetHeaders",
			Handler:    _Bchrpc_GetHeaders_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _Bchrpc_GetTransaction_Handler,
		},
		{
			MethodName: "GetRawTransaction",
			Handler:    _Bchrpc_GetRawTransaction_Handler,
		},
		{
			MethodName: "GetAddressTransactions",
			Handler:    _Bchrpc_GetAddressTransactions_Handler,
		},
		{
			MethodName: "GetRawAddressTransactions",
			Handler:    _Bchrpc_GetRawAddressTransactions_Handler,
		},
		{
			MethodName: "GetAddressUnspentOutputs",
			Handler:    _Bchrpc_GetAddressUnspentOutputs_Handler,
		},
		{
			MethodName: "GetUnspentOutput",
			Handler:    _Bchrpc_GetUnspentOutput_Handler,
		},
		{
			MethodName: "GetMerkleProof",
			Handler:    _Bchrpc_GetMerkleProof_Handler,
		},
		{
			MethodName: "GetSlpTokenMetadata",
			Handler:    _Bchrpc_GetSlpTokenMetadata_Handler,
		},
		{
			MethodName: "GetSlpParsedScript",
			Handler:    _Bchrpc_GetSlpParsedScript_Handler,
		},
		{
			MethodName: "GetSlpTrustedValidation",
			Handler:    _Bchrpc_GetSlpTrustedValidation_Handler,
		},
		{
			MethodName: "CheckSlpTransaction",
			Handler:    _Bchrpc_CheckSlpTransaction_Handler,
		},
		{
			MethodName: "SubmitTransaction",
			Handler:    _Bchrpc_SubmitTransaction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _Bchrpc_SubscribeTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTransactionStream",
			Handler:       _Bchrpc_SubscribeTransactionStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeBlocks",
			Handler:       _Bchrpc_SubscribeBlocks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "bchrpc.proto",
}
